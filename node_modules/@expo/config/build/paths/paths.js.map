{"version":3,"file":"paths.js","sourceRoot":"","sources":["../../src/paths/paths.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport path from 'path';\nimport findWorkspaceRoot from 'find-yarn-workspace-root';\n\nimport resolveFrom from 'resolve-from';\nimport { getConfig } from '../Config';\nimport { resolveModule } from '../Modules';\nimport { getManagedExtensions } from './extensions';\n\n// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nexport function ensureSlash(inputPath: string, needsSlash: boolean): string {\n  const hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  } else {\n    return inputPath;\n  }\n}\n\nexport function getModulesPath(projectRoot: string): string {\n  const workspaceRoot = findWorkspaceRoot(path.resolve(projectRoot)); // Absolute path or null\n  if (workspaceRoot) {\n    return path.resolve(workspaceRoot, 'node_modules');\n  }\n\n  return path.resolve(projectRoot, 'node_modules');\n}\n\nexport function getPossibleProjectRoot(): string {\n  return fs.realpathSync(process.cwd());\n}\n\nexport function getAbsolutePathWithProjectRoot(\n  projectRoot: string,\n  ...pathComponents: string[]\n): string {\n  // Simple check if we are dealing with an URL\n  if (pathComponents && pathComponents.length === 1 && pathComponents[0].startsWith('http')) {\n    return pathComponents[0];\n  }\n\n  return path.resolve(projectRoot, ...pathComponents);\n}\n\nexport function getEntryPoint(\n  projectRoot: string,\n  entryFiles: string[],\n  platforms: string[]\n): string | null {\n  const extensions = getManagedExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions);\n}\n\n// Used to resolve the main entry file for a project.\nexport function getEntryPointWithExtensions(\n  projectRoot: string,\n  entryFiles: string[],\n  extensions: string[]\n): string {\n  const { exp, pkg } = getConfig(projectRoot, { skipSDKVersionRequirement: true });\n\n  // This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n  // We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    // If the field exists then we want to test it against every one of the supplied extensions\n    // to ensure the bundler resolves the same way.\n    let entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n      if (!entry)\n        throw new Error(\n          `Cannot resolve entry file: The \\`expo.entryPoint\\` field defined in your \\`app.json\\` points to a non-existent path.`\n        );\n    }\n    return entry;\n  } else if (pkg) {\n    // If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\n    const { main } = pkg;\n    if (main && typeof main === 'string') {\n      // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n      let entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!entry) {\n        // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n        entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!entry)\n          throw new Error(\n            `Cannot resolve entry file: The \\`main\\` field defined in your \\`package.json\\` points to a non-existent path.`\n          );\n      }\n      return entry;\n    }\n  }\n\n  // Now we will start looking for a default entry point using the provided `entryFiles` argument.\n  // This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\n  for (const fileName of entryFiles) {\n    const entry = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (entry) return entry;\n  }\n\n  try {\n    // If none of the default files exist then we will attempt to use the main Expo entry point.\n    // This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n    // Doing this enables us to create a bare minimum Expo project.\n\n    // TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\n    return resolveModule('expo/AppEntry', projectRoot, exp);\n  } catch (_) {\n    throw new Error(\n      `The project entry file could not be resolved. Please either define it in the \\`package.json\\` (main), \\`app.json\\` (expo.entryPoint), create an \\`index.js\\`, or install the \\`expo\\` package.`\n    );\n  }\n}\n\n// Resolve from but with the ability to resolve like a bundler\nexport function resolveFromSilentWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  for (const extension of extensions) {\n    const modulePath = resolveFrom.silent(fromDirectory, `${moduleId}.${extension}`);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return resolveFrom.silent(fromDirectory, moduleId) || null;\n}\n\n// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nexport function getFileWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  const modulePath = path.join(fromDirectory, moduleId);\n  if (fs.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (const extension of extensions) {\n    const modulePath = path.join(fromDirectory, `${moduleId}.${extension}`);\n    if (fs.existsSync(modulePath)) {\n      return modulePath;\n    }\n  }\n  return null;\n}\n"]}